# 10.4. Otros objetos de BD
# Descripción de Triggers
# MODULO 1

## trg_generar_cod_equipos
Genera de forma automática un código único para cada nuevo equipo insertado en la tabla `Equipos`, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_equipos()
RETURNS TRIGGER AS $$
DECLARE
  total_registros INT;
BEGIN
  IF NEW.COD_Equipos IS NULL THEN
    SELECT COUNT(*) + 1 INTO total_registros FROM Equipos;
    NEW.COD_Equipos := 'EQ' || LPAD(total_registros::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_equipos ON Equipos;

CREATE TRIGGER trg_generar_cod_equipos
BEFORE INSERT ON Equipos
FOR EACH ROW
EXECUTE FUNCTION generar_cod_equipos();
```

## trg_generar_cod_maquina_sustituta
Automatiza la asignación de códigos únicos para máquinas sustitutas en la tabla `MAQUINAS_SUSTITUTAS`, asegurando un formato consistente y secuencial.

```sql
CREATE OR REPLACE FUNCTION generar_cod_maquina_sustituta()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.COD_MAQUINAS_SUSTITUTAS IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM MAQUINAS_SUSTITUTAS;
    NEW.COD_MAQUINAS_SUSTITUTAS := 'MS' || LPAD(total::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_maquina_sustituta ON MAQUINAS_SUSTITUTAS;

CREATE TRIGGER trg_generar_cod_maquina_sustituta
BEFORE INSERT ON MAQUINAS_SUSTITUTAS
FOR EACH ROW
EXECUTE FUNCTION generar_cod_maquina_sustituta();
```

## trg_generar_cod_planificacion
Se encarga de crear códigos únicos para las planificaciones de asignación, siguiendo un patrón definido, que ayuda en la gestión y referencia clara de cada planificación.

```sql
PLANIFICACIONES_ASIGNACION
CREATE OR REPLACE FUNCTION generar_cod_planificacion()
RETURNS TRIGGER AS $$
DECLARE
  total_registros INT;
BEGIN
  IF NEW.COD_PLANIFICACIONES_ASIGNACION IS NULL THEN
    SELECT COUNT(*) + 1 INTO total_registros FROM PLANIFICACIONES_ASIGNACION;
    NEW.COD_PLANIFICACIONES_ASIGNACION := 'PA' || LPAD(total_registros::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_planificacion ON PLANIFICACIONES_ASIGNACION;

CREATE TRIGGER trg_generar_cod_planificacion
BEFORE INSERT ON PLANIFICACIONES_ASIGNACION
FOR EACH ROW
EXECUTE FUNCTION generar_cod_planificacion();

```
## trg_generar_cod_prog_mantenimientos

Genera automáticamente un código único y secuencial para cada nuevo registro en la tabla PROG_MANTENIMIENTOS, con formato 'PM' seguido de seis dígitos (ejemplo: PM000001). Esto asegura la identificación estandarizada y evita duplicados manuales en la clave primaria o código del mantenimiento.

```sql
CREATE OR REPLACE FUNCTION generar_cod_prog_mantenimientos()
RETURNS TRIGGER AS $$
DECLARE
  total_registros INT;
BEGIN
  IF NEW.COD_PROG_MANTENIMIENTOS IS NULL THEN
    SELECT COUNT(*) + 1 INTO total_registros FROM PROG_MANTENIMIENTOS;
    NEW.COD_PROG_MANTENIMIENTOS := 'PM' || LPAD(total_registros::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Eliminar trigger si ya existe
DROP TRIGGER IF EXISTS trg_generar_cod_prog_mantenimientos ON PROG_MANTENIMIENTOS;

-- Crear trigger que llama a la función antes de insertar
CREATE TRIGGER trg_generar_cod_prog_mantenimientos
BEFORE INSERT ON PROG_MANTENIMIENTOS
FOR EACH ROW
EXECUTE FUNCTION generar_cod_prog_mantenimientos();

```

# genera reporte de planificacion 
  Se activa automáticamente después de cada inserción en `PLANIFICACIONES_ASIGNACION`.  
  Llama a la función para generar el reporte y el historial.
```sql
CREATE OR REPLACE FUNCTION trg_planificacion_after_insert()
RETURNS TRIGGER AS $$
DECLARE
  v_id_reporte INT;
  v_total INT;
  v_cod_reporte CHAR(8);
BEGIN
  -- Calcular total filas + 1 para el código
  SELECT COUNT(*) + 1 INTO v_total FROM REPORTE_EQUIPOS;

  -- Formatear código 'RE' + 6 dígitos con ceros a la izquierda
  v_cod_reporte := 'RE' || LPAD(v_total::text, 6, '0');

  -- Insertar nuevo registro en REPORTE_EQUIPOS
  INSERT INTO REPORTE_EQUIPOS (
    COD_REPORTE_EQUIPOS,
    ID_EQUIPOS,
    ID_PLANIFICACIONES_ASIGNACION,
    ID_PROG_MANTENIMIENTOS
  ) VALUES (
    v_cod_reporte,
    NEW.ID_EQUIPOS,
    NEW.ID_PLANIFICACIONES_ASIGNACION,
    NULL
  )
  RETURNING ID_REPORTE_EQUIPOS INTO v_id_reporte;

  -- Insertar en historial
  INSERT INTO Historial_Estado_Equipo (
    ID_EQUIPOS,
    Fecha,
    ID_Estado_equipo,
    Detalle
  )
  VALUES (
    NEW.ID_EQUIPOS,
    CURRENT_DATE,
    (SELECT ID_Estado_equipo FROM EQUIPOS WHERE ID_EQUIPOS = NEW.ID_EQUIPOS),
    NEW.Descripcion_de_tarea
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_planificacion_ai ON PLANIFICACIONES_ASIGNACION;

CREATE TRIGGER trg_planificacion_ai
AFTER INSERT ON PLANIFICACIONES_ASIGNACION
FOR EACH ROW
EXECUTE FUNCTION trg_planificacion_after_insert();

```
# genera reporte de programacion mantenimiento
Se activa automáticamente después de cada inserción en `PROG_MANTENIMIENTOS`.  
  Invoca la función para crear el reporte y registrar el historial.
```sql
CREATE OR REPLACE FUNCTION trg_mantenimiento_after_insert()
RETURNS TRIGGER AS $$
DECLARE
  v_id_reporte INT;
  v_total INT;
  v_cod_reporte CHAR(8);
  v_detalle VARCHAR(100);
BEGIN
  -- Calcular total filas + 1 para el código
  SELECT COUNT(*) + 1 INTO v_total FROM REPORTE_EQUIPOS;

  -- Formatear código 'RE' + 6 dígitos con ceros a la izquierda
  v_cod_reporte := 'RE' || LPAD(v_total::text, 6, '0');

  -- Obtener detalle mantenimiento, si existe
  SELECT COALESCE(md.Detalle_mantenimiento_realizado, 'Mantenimiento registrado')
  INTO v_detalle
  FROM Mantenimiento_detalle md
  WHERE md.ID_PROG_MANTENIMIENTOS = NEW.ID_PROG_MANTENIMIENTOS
  LIMIT 1;

  IF v_detalle IS NULL THEN
    v_detalle := 'Mantenimiento registrado';
  END IF;

  -- Insertar nuevo registro en REPORTE_EQUIPOS
  INSERT INTO REPORTE_EQUIPOS (
    COD_REPORTE_EQUIPOS,
    ID_EQUIPOS,
    ID_PLANIFICACIONES_ASIGNACION,
    ID_PROG_MANTENIMIENTOS
  ) VALUES (
    v_cod_reporte,
    NEW.ID_EQUIPOS,
    NULL,
    NEW.ID_PROG_MANTENIMIENTOS
  )
  RETURNING ID_REPORTE_EQUIPOS INTO v_id_reporte;

  -- Insertar en historial
  INSERT INTO Historial_Estado_Equipo (
    ID_EQUIPOS,
    Fecha,
    ID_Estado_equipo,
    Detalle
  )
  VALUES (
    NEW.ID_EQUIPOS,
    COALESCE(NEW.Fecha_de_inicio, CURRENT_DATE),
    (SELECT ID_Estado_equipo FROM EQUIPOS WHERE ID_EQUIPOS = NEW.ID_EQUIPOS),
    v_detalle
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_mantenimiento_ai ON PROG_MANTENIMIENTOS;

CREATE TRIGGER trg_mantenimiento_ai
AFTER INSERT ON PROG_MANTENIMIENTOS
FOR EACH ROW
EXECUTE FUNCTION trg_mantenimiento_after_insert();

```
Sample content for section 10.4.
=======



# MODULO 2: GESTIÓN DE INVENTARIOS

## Función que se ejecuta antes de Insert en Movimiento_Inventario
### Pasos

- Crear una función PL/pgSQL que se ejecute **antes de insert** en `Movimiento_inventario`.
- La función asignará:
  - `cod_movimiento_inventario` usando el próximo `id_movimiento_inventario` (por ejemplo, con formato `MOV` + id con ceros a la izquierda).
  - `id_producto` consultando la tabla `Lote` según `id_lote`.
-- 1. Función trigger:
```sql
CREATE OR REPLACE FUNCTION trg_set_codigo_y_producto()
RETURNS TRIGGER AS $$
DECLARE
    nuevo_codigo TEXT;
    producto_lote CHAR(8);
BEGIN
    -- Obtener id_producto desde Lote según id_lote que se inserta
    SELECT id_producto INTO producto_lote FROM Lote WHERE id_lote = NEW.id_lote;
    IF producto_lote IS NULL THEN
        RAISE EXCEPTION 'El id_lote % no tiene producto asociado', NEW.id_lote;
    END IF;
    
    -- Asignar id_producto automáticamente
    NEW.id_producto := producto_lote;

    -- Asignar cod_movimiento_inventario si no se ha puesto (por si quieres permitirlo manual)
    IF NEW.cod_movimiento_inventario IS NULL OR NEW.cod_movimiento_inventario = '' THEN
        -- Para generar el código basado en id_movimiento_inventario, primero insertemos con un valor temporal
        -- Pero como el ID es serial y se genera luego, debemos generar un código provisional con nextval
        
        -- Obtener el próximo id_movimiento_inventario para usarlo en el código
        -- IMPORTANTE: El ID no está generado aún porque es BEFORE INSERT, así que usamos la secuencia manualmente
        nuevo_codigo := 'MOV' || LPAD(nextval(pg_get_serial_sequence('Movimiento_inventario','id_movimiento_inventario'))::text, 5, '0');
        NEW.cod_movimiento_inventario := nuevo_codigo;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```
-- 2. Crear trigger BEFORE INSERT en Movimiento_inventario
```sql
CREATE TRIGGER trg_before_insert_movimiento
BEFORE INSERT ON Movimiento_inventario
FOR EACH ROW
EXECUTE FUNCTION trg_set_codigo_y_producto();
```
# Explicación

- `nextval(pg_get_serial_sequence(...))` obtiene el próximo valor de la secuencia usada para el `id_movimiento_inventario`.
- `LPAD(..., 6, '0')` rellena con ceros a la izquierda para que quede con 6 dígitos (ejemplo: `MOV000123`).
- La función valida que el lote tenga producto asociado; si no, lanza error para evitar inconsistencias.
- El trigger se ejecuta antes de insertar para modificar los datos del nuevo registro.

```sql
-- 1. Eliminar el trigger (nombre y tabla)
DROP TRIGGER IF EXISTS trg_before_insert_movimiento ON Movimiento_inventario;

-- 2. Eliminar la función (nombre)
DROP FUNCTION IF EXISTS trg_set_codigo_y_producto();
```

## Función para generar alertas de inventario

```sql
CREATE OR REPLACE FUNCTION fn_check_alertas_inventario()
RETURNS TRIGGER AS $$
DECLARE
    dias_para_vencimiento INT;
    stock_actual FLOAT;
    stock_max FLOAT;
    mensaje TEXT;
    id_empleado_responsable INT := NULL; -- Puedes asignar un responsable fijo si quieres
    seq_val BIGINT;
BEGIN
    -- Calcular días para vencimiento del lote
    IF NEW.fecha_vencimiento IS NOT NULL THEN
        dias_para_vencimiento := (NEW.fecha_vencimiento - CURRENT_DATE);
    ELSE
        dias_para_vencimiento := NULL;
    END IF;

    -- Calcular stock actual sumando entradas y restando salidas para este lote
    SELECT COALESCE(SUM(
        CASE
            WHEN mi.id_tipo_movimiento = 'E' THEN mi.cantidad
            WHEN mi.id_tipo_movimiento = 'S' THEN -mi.cantidad
            ELSE 0
        END), 0)
    INTO stock_actual
    FROM Movimiento_inventario mi
    WHERE mi.id_lote = NEW.id_lote;

    -- Obtener stock máximo del producto
    SELECT s.stock_maximo INTO stock_max
    FROM Stock s
    WHERE s.id_producto = NEW.id_producto;

    -- Obtener valor siguiente de secuencia para código
    seq_val := nextval(pg_get_serial_sequence('Alerta_inventario','id_alerta_inventario'));

    -- ** Alerta por vencimiento cercano (1 día antes) **
    IF dias_para_vencimiento = 1 THEN
        mensaje := 'Alerta: Lote ' || NEW.cod_lote || ' vence mañana.';
        INSERT INTO Alerta_inventario (
            cod_alerta_inventario,
            estado_alerta,
            tipo_alerta,
            severidad,
            descripcion,
            fecha_hora_alerta,
            id_lote,
            id_empleado_responsable
        ) VALUES (
            'ALRT' || LPAD(seq_val::text, 4, '0'),
            'Pendiente',
            'Vencimiento',
            'Alta',
            mensaje,
            NOW(),
            NEW.id_lote,
            id_empleado_responsable
        );
    END IF;

    -- ** Alerta si stock disponible se acerca al máximo (ejemplo, 90% o más) **
    IF stock_max IS NOT NULL AND stock_actual >= (stock_max * 0.9) THEN
        -- Obtener siguiente valor secuencia para nuevo código
        seq_val := nextval(pg_get_serial_sequence('Alerta_inventario','id_alerta_inventario'));

        mensaje := 'Alerta: Stock del lote ' || NEW.cod_lote || ' está al ' || ROUND((stock_actual/stock_max)*100,2) || '% del máximo.';
        INSERT INTO Alerta_inventario (
            cod_alerta_inventario,
            estado_alerta,
            tipo_alerta,
            severidad,
            descripcion,
            fecha_hora_alerta,
            id_lote,
            id_empleado_responsable
        ) VALUES (
            'ALRT' || LPAD(seq_val::text, 4, '0'),
            'Pendiente',
            'Stock alto',
            'Media',
            mensaje,
            NOW(),
            NEW.id_lote,
            id_empleado_responsable
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Paso 2: Crear el trigger para la tabla Lote

El trigger se ejecutará después de insertar o actualizar un lote para verificar y generar alertas si aplica.

```sql
CREATE TRIGGER trg_alertas_lote
AFTER INSERT OR UPDATE ON Lote
FOR EACH ROW
EXECUTE FUNCTION fn_check_alertas_inventario();
```





# MODULO 3

## trg_cod_packing
Genera de forma automática un código único para cada nuevo packing, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_packing()
RETURNS TRIGGER AS $$
DECLARE
    total INT;
BEGIN
    IF NEW.cod_packing IS NULL THEN
        SELECT COUNT(*) + 1 INTO total FROM Packing;
        NEW.cod_packing := 'PKG' || LPAD(total::TEXT, 5, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_cod_packing ON Packing;

CREATE TRIGGER trg_cod_packing
BEFORE INSERT ON Packing
FOR EACH ROW
EXECUTE FUNCTION generar_cod_packing();

```

## trg_cod_reporte_packing
Genera de forma automática un código único para cada nuevo reporte de packing, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_reporte_packing()
RETURNS TRIGGER AS $$
DECLARE
    total INT;
BEGIN
    IF NEW.cod_reporte_packing IS NULL THEN
        SELECT COUNT(*) + 1 INTO total FROM Reporte_Packing;
        NEW.cod_reporte_packing := 'RPK' || LPAD(total::TEXT, 5, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_cod_reporte_packing ON Reporte_Packing;

CREATE TRIGGER trg_cod_reporte_packing
BEFORE INSERT ON Reporte_Packing
FOR EACH ROW
EXECUTE FUNCTION generar_cod_reporte_packing();

```

## trg_cod_empaque
Genera de forma automática un código único para cada nuevo empaque, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_empaque()
RETURNS TRIGGER AS $$
DECLARE
    total INT;
BEGIN
    IF NEW.cod_empaque IS NULL THEN
        SELECT COUNT(*) + 1 INTO total FROM Empaque;
        NEW.cod_empaque := 'EMP' || LPAD(total::TEXT, 5, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_cod_empaque ON Empaque;

CREATE TRIGGER trg_cod_empaque
BEFORE INSERT ON Empaque
FOR EACH ROW
EXECUTE FUNCTION generar_cod_empaque();

```



# MODULO 4

trg_generar_cod_lote
Genera de forma automática un código único para cada nuevo lote, estandarizando la identificación mediante prefijo 'LOT' y un número consecutivo.

```sql
CREATE OR REPLACE FUNCTION generar_cod_lote()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.cod_lote IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM Lote;
    NEW.cod_lote := 'LOT' || LPAD(total::TEXT, 5, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_lote ON Lote;

CREATE TRIGGER trg_generar_cod_lote
BEFORE INSERT ON Lote
FOR EACH ROW
EXECUTE FUNCTION generar_cod_lote();
```

trg_generar_cod_recepcion
Asigna automáticamente un código único a cada nueva recepción con el prefijo 'REC', asegurando un formato consistente y evitando duplicados.

```sql
CREATE OR REPLACE FUNCTION generar_cod_recepcion()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.cod_recepcion IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM Recepcion;
    NEW.cod_recepcion := 'REC' || LPAD(total::TEXT, 5, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_recepcion ON Recepcion;

CREATE TRIGGER trg_generar_cod_recepcion
BEFORE INSERT ON Recepcion
FOR EACH ROW
EXECUTE FUNCTION generar_cod_recepcion();
```

trg_generar_cod_control_calidad
Crea automáticamente un código único para cada control de calidad usando el prefijo 'QC' y una secuencia numérica de seis dígitos.

```sql
CREATE OR REPLACE FUNCTION generar_cod_control_calidad()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.cod_control_calidad IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM Control_de_calidad;
    NEW.cod_control_calidad := 'QC' || LPAD(total::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generar_cod_control_calidad ON Control_de_calidad;

CREATE TRIGGER trg_generar_cod_control_calidad
BEFORE INSERT ON Control_de_calidad
FOR EACH ROW
EXECUTE FUNCTION generar_cod_control_calidad();
```

# MODULO 5

## trg_generar_cod_guia_remision
Genera de forma automática un código único para cada nueva guia de remision, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
DROP TRIGGER IF EXISTS trg_cod_guia_remision ON Guia_de_Remision;

DROP FUNCTION IF EXISTS generar_cod_guia_remision;


CREATE OR REPLACE FUNCTION generar_cod_guia_remision()
RETURNS TRIGGER AS $$
DECLARE
    total INT;
BEGIN
    IF NEW.cod_guia_remision IS NULL OR NEW.cod_guia_remision = '' THEN
        SELECT COUNT(*) + 1 INTO total FROM Guia_de_Remision;
        NEW.cod_guia_remision := 'GR' || LPAD(total::TEXT, 6, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_cod_guia_remision
BEFORE INSERT ON Guia_de_Remision
FOR EACH ROW
EXECUTE FUNCTION generar_cod_guia_remision();

```
## trg_generar_cod_orden_transporte
Genera de forma automática un código único para cada nueva orden_transporte, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
DROP TRIGGER IF EXISTS trg_cod_orden_transporte ON orden_transporte;

DROP FUNCTION IF EXISTS generar_cod_orden_transporte;

CREATE OR REPLACE FUNCTION generar_cod_orden_transporte()
RETURNS TRIGGER AS $$
DECLARE
    total INT;
BEGIN
    IF NEW.cod_orden_transporte IS NULL OR NEW.cod_orden_transporte = '' THEN
        SELECT COUNT(*) + 1 INTO total FROM orden_transporte;
        NEW.cod_orden_transporte := 'OT' || LPAD(total::TEXT, 6, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_cod_orden_transporte
BEFORE INSERT ON orden_transporte
FOR EACH ROW
EXECUTE FUNCTION generar_cod_orden_transporte();

```

# MODULO 6
## trg_generar_cod_procesos
Genera de forma automática un código único para cada nuevo proceso, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_procesos()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.cod_procesos IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM PROCESOS;
    NEW.cod_procesos := 'PRC' || LPAD(total::TEXT, 5, '0');

DROP TRIGGER IF EXISTS trg_cod_procesos ON PROCESOS;

CREATE TRIGGER trg_cod_procesos
BEFORE INSERT ON PROCESOS
FOR EACH ROW
EXECUTE FUNCTION generar_cod_procesos();
```



## trg_generar_cod_reporte
Genera de forma automática un código único para cada nuevo reporte de trazabilidad, facilitando la identificación estandarizada y evitando duplicados manuales.

```sql
CREATE OR REPLACE FUNCTION generar_cod_reporte()

IF NEW.cod_reporte_trazabilidad IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM REPORTE_TRAZABILIDAD;
    NEW.cod_reporte_trazabilidad := 'RPT' || LPAD(total::TEXT, 5, '0');


DROP TRIGGER IF EXISTS trg_cod_reporte ON REPORTE_TRAZABILIDAD;

CREATE TRIGGER trg_cod_reporte
BEFORE INSERT ON REPORTE_TRAZABILIDAD
FOR EACH ROW
EXECUTE FUNCTION generar_cod_reporte();

```


## trg_generar_cod_incidencias
Genera de forma automática un código único para cada nueva incidencia , facilitando la identificación estandarizada y evitando duplicados manuales.

```sql

CREATE OR REPLACE FUNCTION generar_cod_incidencias()
RETURNS TRIGGER AS $$
DECLARE
  total INT;
BEGIN
  IF NEW.cod_incidencias IS NULL THEN
    SELECT COUNT(*) + 1 INTO total FROM INCIDENCIAS;
    NEW.cod_incidencias := 'INC' || LPAD(total::TEXT, 5, '0');
DROP TRIGGER IF EXISTS trg_cod_incidencias ON INCIDENCIAS;

CREATE TRIGGER trg_cod_incidencias
BEFORE INSERT ON INCIDENCIAS
FOR EACH ROW
EXECUTE FUNCTION generar_cod_incidencias();

```












Sample content for section 10.4.

